// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// Check for compatibility between `uniffi` and `uniffi_bindgen` versions.
// Note that we have an error message on the same line as the assertion.
// This is important, because if the assertion fails, the compiler only
// seems to show that single line as context for the user.
uniffi::assert_compatible_version!("0.12.0"); // Please check that you depend on version 0.12.0 of the `uniffi` crate.

// Everybody gets basic buffer support, since it's needed for passing complex types over the FFI.

/// This helper allocates a new byte buffer owned by the Rust code, and returns it
/// to the foreign-language code as a `RustBuffer` struct. Callers must eventually
/// free the resulting buffer, either by explicitly calling the destructor defined below,
/// or by passing ownership of the buffer back into Rust code.
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_library_8bbb_rustbuffer_alloc(
    size: i32,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> uniffi::RustBuffer {
    uniffi::deps::ffi_support::call_with_output(err, || {
        uniffi::RustBuffer::new_with_size(size.max(0) as usize)
    })
}

/// This helper copies bytes owned by the foreign-language code into a new byte buffer owned
/// by the Rust code, and returns it as a `RustBuffer` struct. Callers must eventually
/// free the resulting buffer, either by explicitly calling the destructor defined below,
/// or by passing ownership of the buffer back into Rust code.
///
/// # Safety
/// This function will dereference a provided pointer in order to copy bytes from it, so
/// make sure the `ForeignBytes` struct contains a valid pointer and length.
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_library_8bbb_rustbuffer_from_bytes(
    bytes: uniffi::ForeignBytes,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> uniffi::RustBuffer {
    uniffi::deps::ffi_support::call_with_output(err, || {
        let bytes = bytes.as_slice();
        uniffi::RustBuffer::from_vec(bytes.to_vec())
    })
}

/// Free a byte buffer that had previously been passed to the foreign language code.
///
/// # Safety
/// The argument *must* be a uniquely-owned `RustBuffer` previously obtained from a call
/// into the Rust code that returned a buffer, or you'll risk freeing unowned memory or
/// corrupting the allocator state.
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_library_8bbb_rustbuffer_free(
    buf: uniffi::RustBuffer,
    err: &mut uniffi::deps::ffi_support::ExternError,
) {
    uniffi::deps::ffi_support::call_with_output(err, || uniffi::RustBuffer::destroy(buf))
}

/// Reserve additional capacity in a byte buffer that had previously been passed to the
/// foreign language code.
///
/// The first argument *must* be a uniquely-owned `RustBuffer` previously
/// obtained from a call into the Rust code that returned a buffer. Its underlying data pointer
/// will be reallocated if necessary and returned in a new `RustBuffer` struct.
///
/// The second argument must be the minimum number of *additional* bytes to reserve
/// capacity for in the buffer; it is likely to reserve additional capacity in practice
/// due to amortized growth strategy of Rust vectors.
///
/// # Safety
/// The first argument *must* be a uniquely-owned `RustBuffer` previously obtained from a call
/// into the Rust code that returned a buffer, or you'll risk freeing unowned memory or
/// corrupting the allocator state.
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_library_8bbb_rustbuffer_reserve(
    buf: uniffi::RustBuffer,
    additional: i32,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> uniffi::RustBuffer {
    uniffi::deps::ffi_support::call_with_output(err, || {
        use std::convert::TryInto;
        let additional: usize = additional
            .try_into()
            .expect("additional buffer length negative or overflowed");
        let mut v = buf.destroy_into_vec();
        v.reserve(additional);
        uniffi::RustBuffer::from_vec(v)
    })
}

/// Free a String that had previously been passed to the foreign language code.
///
/// # Safety
///
/// In order to free the string, Rust takes ownership of a raw pointer which is an
/// unsafe operation. The argument *must* be a uniquely-owned pointer previously
/// obtained from a call into the rust code that returned a string.
/// (In practice that means you got it from the `message` field of an `ExternError`,
/// because that's currently the only place we use `char*` types in our API).
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_library_8bbb_string_free(
    cstr: *mut std::os::raw::c_char,
    err: &mut uniffi::deps::ffi_support::ExternError,
) {
    uniffi::deps::ffi_support::call_with_output(err, || {
        uniffi::deps::ffi_support::destroy_c_string(cstr)
    })
}

// We generate error mappings into ffi_support::ExternErrors
// so that the errors can propagate through the FFI

#[doc(hidden)]
impl From<ArithmeticError> for uniffi::deps::ffi_support::ExternError {
    fn from(err: ArithmeticError) -> uniffi::deps::ffi_support::ExternError {
        // Errno just differentiate between the errors.
        // They are in-order, i.e the first variant of the enum has code 1
        // As we add support for generic errors (e.g panics)
        // we might find that we need to reserve some codes.
        match err {
            ArithmeticError::IntegerOverflow { .. } => {
                uniffi::deps::ffi_support::ExternError::new_error(
                    uniffi::deps::ffi_support::ErrorCode::new(1),
                    err.to_string(),
                )
            }
        }
    }
}

// Enum defitions, corresponding to `enum` in UDL.

// Record definitions, implemented as method-less structs, corresponding to `dictionary` objects.

#[doc(hidden)]
unsafe impl uniffi::ViaFfi for Point {
    type FfiType = uniffi::RustBuffer;

    fn lower(self) -> Self::FfiType {
        uniffi::lower_into_buffer(self)
    }

    fn try_lift(v: Self::FfiType) -> uniffi::deps::anyhow::Result<Self> {
        uniffi::try_lift_from_buffer(v)
    }

    fn write<B: uniffi::deps::bytes::BufMut>(&self, buf: &mut B) {
        // If the provided struct doesn't match the fields declared in the UDL, then
        // the generated code here will fail to compile with somewhat helpful error.
        uniffi::ViaFfi::write(&self.x, buf);
        uniffi::ViaFfi::write(&self.y, buf);
    }

    fn try_read<B: uniffi::deps::bytes::Buf>(buf: &mut B) -> uniffi::deps::anyhow::Result<Self> {
        Ok(Self {
            x: <f64 as uniffi::ViaFfi>::try_read(buf)?,
            y: <f64 as uniffi::ViaFfi>::try_read(buf)?,
        })
    }
}

// Top level functions, corresponding to UDL `namespace` functions.

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_bool_inc_test(
    value: i8,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> i8 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_bool_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = bool_inc_test(<bool as uniffi::ViaFfi>::try_lift(value).unwrap());
        <bool as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_i8_inc_test(
    value: i8,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> i8 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_i8_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = i8_inc_test(<i8 as uniffi::ViaFfi>::try_lift(value).unwrap());
        <i8 as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_i16_inc_test(
    value: i16,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> i16 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_i16_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = i16_inc_test(<i16 as uniffi::ViaFfi>::try_lift(value).unwrap());
        <i16 as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_i32_inc_test(
    value: i32,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> i32 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_i32_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = i32_inc_test(<i32 as uniffi::ViaFfi>::try_lift(value).unwrap());
        <i32 as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_i64_inc_test(
    value: i64,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> i64 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_i64_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = i64_inc_test(<i64 as uniffi::ViaFfi>::try_lift(value).unwrap());
        <i64 as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_u8_inc_test(
    value: u8,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> u8 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_u8_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = u8_inc_test(<u8 as uniffi::ViaFfi>::try_lift(value).unwrap());
        <u8 as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_u16_inc_test(
    value: u16,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> u16 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_u16_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = u16_inc_test(<u16 as uniffi::ViaFfi>::try_lift(value).unwrap());
        <u16 as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_u32_inc_test(
    value: u32,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> u32 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_u32_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = u32_inc_test(<u32 as uniffi::ViaFfi>::try_lift(value).unwrap());
        <u32 as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_u64_inc_test(
    value: u64,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> u64 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_u64_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = u64_inc_test(<u64 as uniffi::ViaFfi>::try_lift(value).unwrap());
        <u64 as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_float_inc_test(
    value: f32,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> f32 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_float_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = float_inc_test(<f32 as uniffi::ViaFfi>::try_lift(value).unwrap());
        <f32 as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_double_inc_test(
    value: f64,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> f64 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_double_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = double_inc_test(<f64 as uniffi::ViaFfi>::try_lift(value).unwrap());
        <f64 as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_string_inc_test(
    value: uniffi::RustBuffer,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_string_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = string_inc_test(<String as uniffi::ViaFfi>::try_lift(value).unwrap());
        <String as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_byref_inc_test(
    value: uniffi::RustBuffer,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_byref_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = byref_inc_test(&<Point as uniffi::ViaFfi>::try_lift(value).unwrap());
        <Point as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_optional_type_inc_test(
    value: uniffi::RustBuffer,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_optional_type_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval =
            optional_type_inc_test(<Option<i32> as uniffi::ViaFfi>::try_lift(value).unwrap());
        <Option<i32> as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_vector_inc_test(
    value: uniffi::RustBuffer,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_vector_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = vector_inc_test(<Vec<String> as uniffi::ViaFfi>::try_lift(value).unwrap());
        <Vec<String> as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_hash_map_inc_test(
    value: uniffi::RustBuffer,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> uniffi::RustBuffer {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_hash_map_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = hash_map_inc_test(
            <std::collections::HashMap<String, i32> as uniffi::ViaFfi>::try_lift(value).unwrap(),
        );
        <std::collections::HashMap<String, i32> as uniffi::ViaFfi>::lower(_retval)
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_void_inc_test(
    value: i32,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> () {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_void_inc_test");

    uniffi::deps::ffi_support::call_with_output(err, || {
        let _retval = void_inc_test(<i32 as uniffi::ViaFfi>::try_lift(value).unwrap());
        _retval
    })
}

#[allow(clippy::all)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn library_8bbb_error_inc_test(
    a: u64,
    b: u64,
    err: &mut uniffi::deps::ffi_support::ExternError,
) -> u64 {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("library_8bbb_error_inc_test");

    uniffi::deps::ffi_support::call_with_result(err, || -> Result<u64, ArithmeticError> {
        let _retval = error_inc_test(
            <u64 as uniffi::ViaFfi>::try_lift(a).unwrap(),
            <u64 as uniffi::ViaFfi>::try_lift(b).unwrap(),
        )?;
        Ok(<u64 as uniffi::ViaFfi>::lower(_retval))
    })
}
// Object definitions, correspoding to UDL `interface` definitions.

// Callback Interface defitions, corresponding to UDL `callback interface` definitions.
